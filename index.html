<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="空灵画师的小站~">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="空灵画师的小站~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xuzhangtian">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>空灵画师的小站~</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">空灵画师的小站~</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xuzhangtian"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">xuzhangtian</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/03/seatunnel-engine-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="xuzhangtian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/03/seatunnel-engine-3/" class="post-title-link" itemprop="url">SeaTunnel Engine 设计（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-03 09:36:49 / 修改时间：11:05:25" itemprop="dateCreated datePublished" datetime="2023-08-03T09:36:49+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="TaskExecutionServer"><a href="#TaskExecutionServer" class="headerlink" title="TaskExecutionServer"></a>TaskExecutionServer</h2><p>TaskExecutionServer 的主要功能是负责在每个节点上执行任务。</p>
<ul>
<li><p>任务执行：每个 Server 都会运行一个 TaskExecutionServer 的实例。JobMaster 将作业划分为多个 TaskGroup，每个 TaskGroup 包含一组相关联的 Task 。然后，JobMaster 将这些 TaskGroup 分配给不同的 Worker，由各自的 Worker 负责执行。</p>
</li>
<li><p>TaskContext：在执行任务时，TaskExecutionServer 会为每个 Task 创建一个 TaskContext 对象，并维护一个 TaskID 到 TaskContext 的映射。TaskContext 是一个包含任务执行所需信息的容器，它存储了任务的状态、数据、依赖关系等。所有关于 Task 的操作都会被封装在 TaskContext 中。</p>
</li>
<li><p>OperationService：Task 内部持有一个 OperationService，它是一个提供远程调用和通信能力的服务。这意味着一个 Task 可以通过 OperationService 与其他 Task 或者 JobMaster 进行通信，从而实现任务之间的交互和协作。例如，一个 Task 可以向另一个 Task 请求数据，或者将计算结果汇报给 JobMaster。</p>
</li>
<li><p>在同一个 TaskGroup 内的任务之间，数据通道使用本地队列（Local Queue）。而在不同 TaskGroup 之间的数据通道可能会使用分布式队列（例如Hazelcast Ringbuffer），因为这些任务可能会在不同的节点上执行。</p>
</li>
</ul>
<p><img src="/2023/08/03/seatunnel-engine-3/taskGroup.png" alt="taskGroup.png"></p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>Task 中最重要的方法之一是 call()，执行器通过调用 Task 的 call() 方法来驱动 Task 的操作。call() 方法将返回一个 ProgressState 的值，通过它，执行器可以判断 Task 是否已经结束，以及是否需要继续调用 call() 方法。如下所示。</p>
<p><img src="/2023/08/03/seatunnel-engine-3/call.png" alt="call.png"></p>
<h2 id="线程共享优化"><a href="#线程共享优化" class="headerlink" title="线程共享优化"></a>线程共享优化</h2><p>线程共享优化是在处理大量小任务需要同步执行的情况下，通过让一个线程同时运行多个任务来提高系统效率的一种策略。在这种场景中，如果为每个任务都创建一个独立的线程，将会导致大量线程的创建和销毁，从而浪费大量系统资源。为了避免这种资源浪费，我们可以采用线程共享优化来实现更高效的任务处理。</p>
<p>具体实现方法如下：</p>
<ol>
<li>创建 CooperativeTaskWorker：CooperativeTaskWorker 中包含了一个阻塞任务队列 BlockingQueue 并且实现了 Runnable 的 run() 方法 。</li>
<li>通过线程池提交 CooperativeTaskWorker。</li>
<li>run() 方法会循环的从任务队列中拉取 Task，并且调用 Task 的 call() 方法, 根据 call() 方法的返回值判断该 Task 是否结束，没有结束就放入队尾，直到所有任务都运行结束。</li>
</ol>
<p><img src="/2023/08/03/seatunnel-engine-3/thread.png" alt="thread.png"></p>
<p>这也会带来一个问题，即如果一个任务的 call() 方法执行时间非常长，这个线程将一直被占用，导致其他任务的延迟非常严重。</p>
<p>优化方案一：标记线程共享</p>
<ol>
<li>为 Task 提供一个标记，用于标记是否支持线程共享。任务的具体实现中，根据 call() 方法的执行时间，评估是否支持线程共享。通常，如果任务的 call() 方法的执行时间都在毫秒级别，则可以将该任务标记为支持线程共享。</li>
<li>当任务被标记为支持线程共享时，这些任务会共享一个线程来执行，而不是为每个任务分配独立线程。这样可以避免大量线程的创建和销毁开销，节省系统资源。</li>
<li>对于不支持线程共享的任务，依然为每个任务分配一个独立线程来执行，确保这些任务可以独立运行，不受其他任务的影响。</li>
</ol>
<p>优化方案二：动态线程共享</p>
<ol>
<li>将一组任务交给线程池执行，其中任务数量远大于线程数量。这样，多个任务将共享一个线程来执行。</li>
<li>在线程执行任务的过程中，对任务的 call() 方法执行时间进行监控。如果某个任务的 call() 方法执行时间超过设定阈值（例如100ms），则该线程会从线程池中获取另一个线程，并将后续的任务分配给这个新线程来执行。</li>
<li>这样做的目的是避免因为某个任务执行时间过长而导致其他任务的延迟过高。通过动态地分配线程，保证任务执行的公平性和高效性。</li>
<li>对于 call() 方法在超时时间内正常执行的任务，线程会继续执行后续任务，并将该任务放回任务队列等待下一次执行。</li>
<li>对于某个任务的 call() 方法超时执行次数达到一定限制时，该任务将被移出线程共享队列，并使用一个独立线程来执行。这样可以避免某个任务长期占用共享线程，影响其他任务的执行。</li>
</ol>
<p><img src="/2023/08/03/seatunnel-engine-3/o1.png" alt="o1.png"><br><img src="/2023/08/03/seatunnel-engine-3/o2.png" alt="o2.png"><br><img src="/2023/08/03/seatunnel-engine-3/o3.png" alt="o3.png"><br><img src="/2023/08/03/seatunnel-engine-3/o4.png" alt="o4.png"><br><img src="/2023/08/03/seatunnel-engine-3/o5.png" alt="o5.png"><br><img src="/2023/08/03/seatunnel-engine-3/o6.png" alt="o6.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/02/seatunnel-engine-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="xuzhangtian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/02/seatunnel-engine-2/" class="post-title-link" itemprop="url">SeaTunnel Engine 设计（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-02 09:45:52" itemprop="dateCreated datePublished" datetime="2023-08-02T09:45:52+08:00">2023-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-03 10:04:38" itemprop="dateModified" datetime="2023-08-03T10:04:38+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SeaTunnel-工作流程"><a href="#SeaTunnel-工作流程" class="headerlink" title="SeaTunnel 工作流程"></a>SeaTunnel 工作流程</h2><p><img src="/2023/08/02/seatunnel-engine-2/workflow.png" alt="workflow.png"></p>
<p>如上图所示 SeaTunnel 主要分为 clint 和 server。clint 负责任务的提交，server 负责资源申请和任务调度。</p>
<h3 id="整个工作流程如下"><a href="#整个工作流程如下" class="headerlink" title="整个工作流程如下"></a>整个工作流程如下</h3><ol>
<li>Client 需要构建一个 JobImmutableInformation 对象，并提交给 Server。构建时主要初始化 pluginJarsUrls 和 logicalDag。pluginJarsUrls 是任务必须要依赖的 Jar 包路径，包括 source 和 sink 所需要的数据连接驱动。logicalDag 是任务的逻辑有向无环图，用来描述任务处理操作的传递关系。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobImmutableInformation</span> <span class="keyword">implements</span> <span class="title class_">IdentifiedDataSerializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> jobId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Data logicalDag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JobConfig jobConfig;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;URL&gt; pluginJarsUrls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Server 收到 JobImmutableInformation 后会构建一个 JobMaster ，并通过线程池提交。</li>
<li>JobMaster 初始化时会将 LogicalDag 进行一系列解析，最终得到 PhysicalPlan（上图中的 PhysicalDag）, PhysicalPlan 是最终的执行计划。</li>
<li>JobMaster 中包括 ResourceManager，JobScheduler，PhysicalPlan。JobMaster 的 run 方法会通过 JobScheduler 进行任务调度；JobScheduler 会通过 ResourceManager 去申请必要的资源；申请到资源后任务才会真正的运行。</li>
</ol>
<h3 id="解析-JobConfig-生成-LogicalPlan"><a href="#解析-JobConfig-生成-LogicalPlan" class="headerlink" title="解析 JobConfig 生成 LogicalPlan"></a>解析 JobConfig 生成 LogicalPlan</h3><p>SeaTunnelClient 通过作业配置文件来定义作业流水线，因此 SeaTunnelClient 的首要任务是解析作业配置文件并生成 action 列表。action 类似于 Flink 中的操作符（operator），它是 SeaTunnel API 的封装。每个动作包含 SeaTunnelSource、SeaTunnelTransform 或 SeaTunnelSink 的实例。而且，每个动作都需要知道其自身的上游。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Action</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(<span class="meta">@NonNull</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    List&lt;Action&gt; <span class="title function_">upstream</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUpstream</span><span class="params">(<span class="meta">@NonNull</span> Action action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Action 有多种实现类包括 <code>SourceAction</code>、<code>SinkAction</code> 和 <code>TransformAction</code>。</p>
<p>举两个例子：</p>
<p>如果任务配置只有一个 Source 和一个 Sink，并且最多只有一个 Transform，我们将按以下顺序简单地构建动作流水线。</p>
<p><img src="/2023/08/02/seatunnel-engine-2/example1.png" alt="example1.png"></p>
<p>如果存在多个 Source、多个 Transform 或多个 Sink ，那么会根据 source_table_name 和 result_table_name 来构建动作流水线。在这种情况下，Source 连接器必须有 result_table_name，并且 Transform 连接器必须同时具备 result_table_name 和 source_table_name。<br><img src="/2023/08/02/seatunnel-engine-2/example2.png" alt="example2.png"></p>
<p>关于并行的设计：</p>
<ul>
<li>在 SeaTunnel Engine 中，只有 <code>Source</code> 和 <code>PartitionTransform</code> 这两种连接器支持设置并行性。<code>Source</code> 负责读取数据源的数据，而 <code>PartitionTransform</code> 负责对数据进行转换或处理。通过设置并行性，任务可以被拆分成多个子任务，以实现并行处理数据的目的。</li>
<li>对于不能设置并行性的动作，它们将继承其上游动作的并行性。这意味着如果一个动作没有显式设置并行性，它将使用其上游动作的并行性设置。如果一个动作有多个上游动作，那么该动作的并行性将是其上游动作并行性的总和。这样的设计保证了整个数据同步任务的并行性会逐级递增，使得数据同步可以更高效地利用计算资源。</li>
<li>如果一个动作的并行性等于其上游动作的并行性，那么该动作可以与其上游动作链接，并在同一个子任务中运行。这样可以减少任务之间的通信开销，提高任务执行的效率。<br><img src="/2023/08/02/seatunnel-engine-2/parallelism.png" alt="parallelism.png"></li>
</ul>
<h3 id="从-LogicalPlan-到-PhysicalPlan"><a href="#从-LogicalPlan-到-PhysicalPlan" class="headerlink" title="从 LogicalPlan 到 PhysicalPlan"></a>从 LogicalPlan 到 PhysicalPlan</h3><p>SeaTunnel Engine 将接收 Clint 发送的 LogicalPlan，然后将其转换为可直接执行的 PhysicalPlan。因此，需要经过转换处理逻辑执行计划，并生成物理执行计划。具体过程如下:</p>
<ol>
<li>LogicalPlan</li>
</ol>
<p><img src="/2023/08/02/seatunnel-engine-2/logic.png" alt="logic.png"></p>
<p>在收到 LogicalPlan 后，我们需要移除多余的操作，并验证模式（Transform2 和 Transform5 应该相同）。</p>
<ol start="2">
<li>ExecutionPlan</li>
</ol>
<p><img src="/2023/08/02/seatunnel-engine-2/execution.png" alt="execution.png"></p>
<p>在转换为执行计划时：</p>
<ul>
<li>需要合并 Transform，合并的依据是 Transform 后数据是否会被拆分。</li>
<li>将 Shuffle Action 转换为队列。</li>
<li>转换为多管道执行。</li>
</ul>
<ol start="3">
<li>Physical Plan</li>
</ol>
<p><img src="/2023/08/02/seatunnel-engine-2/physical.png" alt="physical.png"></p>
<p>我们将根据并行度将 Pipeline 拆分为单独的可执行任务，还需要添加 SourceSplitEnumerator 和 SinkAggregatedCommitter 任务。完成这些后，可以将任务发送到任务执行服务。然后，任务可以正常运行。</p>
<ul>
<li>SourceSplitEnumerator 的作用是将输入源分片。分片的逻辑是创建任务配置 partitionNum 数量的 Reader, 读取的数据根据不同的 SourceSplitEnumerator 实现逻辑进行分片，并发送给对应的 Reader 进行消费。</li>
<li>SinkAggregatedCommitter 将进行最后的数据写入。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/01/seatunnel-engine-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="xuzhangtian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/01/seatunnel-engine-1/" class="post-title-link" itemprop="url">SeaTunnel 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-01 13:50:22" itemprop="dateCreated datePublished" datetime="2023-08-01T13:50:22+08:00">2023-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-02 09:30:35" itemprop="dateModified" datetime="2023-08-02T09:30:35+08:00">2023-08-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SeaTunnel-是什么"><a href="#SeaTunnel-是什么" class="headerlink" title="SeaTunnel 是什么"></a>SeaTunnel 是什么</h2><ul>
<li>SeaTunnel 是一个非常易于使用、超高性能的分布式数据集成平台，支持大规模数据的实时同步。它能够每天稳定高效地同步数百亿条数据，并已经被近100家公司投入生产使用。</li>
</ul>
<h2 id="SeaTunnel-可以解决哪些问题"><a href="#SeaTunnel-可以解决哪些问题" class="headerlink" title="SeaTunnel 可以解决哪些问题"></a>SeaTunnel 可以解决哪些问题</h2><ul>
<li>各种数据源：存在数百种常用数据源，其版本不兼容。随着新技术的出现，出现了更多的数据源。用户很难找到一个能够完全快速支持这些数据源的工具。</li>
<li>复杂的同步场景：数据同步需要支持离线全量同步、离线增量同步、CDC（变更数据捕获）、实时同步以及全数据库同步等多种同步场景。</li>
<li>高资源需求：现有的数据集成和数据同步工具通常需要大量计算资源或 JDBC 连接资源，以完成对大量小表的实时同步。这增加了企业的负担。</li>
<li>缺乏质量和监控：数据集成和同步过程经常出现数据丢失或重复。同步过程缺乏监控，无法直观地了解任务过程中数据的真实情况。</li>
<li>复杂的技术栈：企业使用的技术组件各不相同，用户需要为不同组件开发相应的同步程序，以完成数据集成。</li>
<li>管理和维护困难：受限于不同的底层技术组件（如 Flink&#x2F;Spark），离线同步和实时同步通常需要分别开发和管理，增加了管理和维护的难度。</li>
</ul>
<h2 id="SeaTunnel-有哪些特性"><a href="#SeaTunnel-有哪些特性" class="headerlink" title="SeaTunnel 有哪些特性"></a>SeaTunnel 有哪些特性</h2><h3 id="多源支持、生态活跃"><a href="#多源支持、生态活跃" class="headerlink" title="多源支持、生态活跃"></a>多源支持、生态活跃</h3><ul>
<li>SeaTunnel 提供了一个不依赖于特定执行引擎的 Connector API。基于该 API 开发的 Connector（<code>Source</code>, <code>Transform</code>, <code>Sink</code>）可以运行在许多不同的引擎上。</li>
<li>Connector 插件设计允许用户轻松开发自己的 Connector 并将其集成到 SeaTunnel 项目中。目前，SeaTunnel 支持 100 多种 Connector，并且数量不断增加。</li>
</ul>
<h3 id="分布式支持"><a href="#分布式支持" class="headerlink" title="分布式支持"></a>分布式支持</h3><ul>
<li>SeaTunnel Engine 是用<code>Hazelcast</code>做集群管理的，可以独立实现集群管理、快照存储和集群高可用功能。</li>
<li>SeaTunnel 采用分布式快照算法等方法来保证数据的一致性，确保在数据同步过程中不会出现数据丢失或重复</li>
</ul>
<h3 id="多引擎支持"><a href="#多引擎支持" class="headerlink" title="多引擎支持"></a>多引擎支持</h3><ul>
<li>SeaTunnel 默认使用 SeaTunnel 引擎进行数据同步，同时还支持将 Flink 或 Spark 作为 Connector 的执行引擎，以适应企业现有的技术组件。SeaTunnel 支持多个版本的 Spark 和 Flink。</li>
</ul>
<h3 id="数据处理优化"><a href="#数据处理优化" class="headerlink" title="数据处理优化"></a>数据处理优化</h3><ul>
<li>批处理-流处理一体化，基于 SeaTunnel Connector API 开发的 Connector 与离线同步、实时同步、全量同步、增量同步等场景完全兼容，大大降低了数据集成任务的管理难度。</li>
<li>支持多表或整个数据库的同步，解决了过多 JDBC 连接的问题；并支持多表或整个数据库日志的读取和解析，解决了CDC多表同步场景下重复读取和解析日志的问题。</li>
<li>支持并行读写，提供高吞吐量和低延迟的稳定可靠的数据同步能力。</li>
</ul>
<h2 id="SeaTunnel-工作流程图"><a href="#SeaTunnel-工作流程图" class="headerlink" title="SeaTunnel 工作流程图"></a>SeaTunnel 工作流程图</h2><p><img src="/2023/08/01/seatunnel-engine-1/work-flow.png" alt="work-flow.png"><br>SeaTunnel 的运行过程如上图所示。</p>
<p>用户配置作业信息并选择执行引擎来提交作业。</p>
<p>源连接器（Source）负责并行读取数据，并将数据发送给下游的转换器（Transform）或直接发送给数据接收器（Sink），而数据接收器则将数据写入目标地。值得注意的是，源、转换器和数据接收器可以通过用户自行开发和扩展。</p>
<p>SeaTunnel 是一个EL(T) 数据集成平台。因此，在 SeaTunnel 中，转换器只能用于执行一些简单的数据转换操作，例如将某一列的数据转换为大写或小写、更改列名或将一列拆分为多个列。</p>
<p>SeaTunnel 默认使用的引擎是 SeaTunnel Engine。如果选择使用 Flink 或 Spark 引擎，SeaTunnel 将会将连接器打包成 Flink 或 Spark 程序，并提交给 Flink 或 Spark 来运行。</p>
<h2 id="SeaTunnel-核心组件-Connector"><a href="#SeaTunnel-核心组件-Connector" class="headerlink" title="SeaTunnel 核心组件 Connector"></a>SeaTunnel 核心组件 Connector</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://seatunnel.apache.org/docs/2.3.2/category/source-v2">Source Connector</a>: SeaTunnel 支持从各种关系型、图形、NoSQL、文档和内存数据库，以及分布式文件系统（如HDFS）和多种云存储解决方案（如S3和OSS）中读取数据。我们还支持许多常见的SaaS服务的数据读取。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://seatunnel.apache.org/docs/2.3.2/category/transform-v2">Transform Connector</a>: 对于源和目标之间的模式不同的情况，可以使用 Transform 连接器来修改从源读取的模式，使其与目标模式一致。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://seatunnel.apache.org/docs/2.3.2/category/sink-v2">Sink Connector</a>: SeaTunnel 还支持将数据写入各种关系型、图形、NoSQL、文档和内存数据库，以及分布式文件系统（如HDFS）和多种云存储解决方案（如S3和OSS）。我们也支持将数据写入许多常见的SaaS服务。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/31/flink-oom-record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="xuzhangtian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 空灵画师的小站~">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/31/flink-oom-record/" class="post-title-link" itemprop="url">记一次 Flink 引发的 Metaspace OOM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-31 15:39:35 / 修改时间：16:42:45" itemprop="dateCreated datePublished" datetime="2023-07-31T15:39:35+08:00">2023-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>项目中有一个需求，将结构化数据采集到<code>Elasticsearch</code>和<code>Nebula Graph</code>中。由于已经有其他项目完成了相关的<code>Flink Sink</code>组件，但该项目不想单独部署一个<code>Flink</code>集群来执行数据采集。</p>
<p>因此，直接通过构建 <code>StreamExecutionEnvironment</code>并调用<code>executeAsync()</code>方法来实现<code>Flink</code>将在本地创建相应的环境并执行任务。以下是相关的代码（文档上说这样<strong>仅供测试使用</strong>，但是我不）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleDataWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">StreamExecutionProps</span> <span class="variable">props</span> <span class="operator">=</span> JsonUtils.objectMapper.readValue(readJson(<span class="string">&quot;props.json&quot;</span>), StreamExecutionProps.class);</span><br><span class="line">    props.fieldTypesAndRowTypeInit();</span><br><span class="line">    <span class="type">DbInfo</span> <span class="variable">nebula</span> <span class="operator">=</span> JsonUtils.objectMapper.readValue(readJson(<span class="string">&quot;nebula.json&quot;</span>), DbInfo.class);</span><br><span class="line">    <span class="type">DbInfo</span> <span class="variable">es</span> <span class="operator">=</span> JsonUtils.objectMapper.readValue(readJson(<span class="string">&quot;es.json&quot;</span>), DbInfo.class);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironmentBuilder.env(props, nebula, es)) &#123;</span><br><span class="line">        env.executeAsync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来这段代码似乎没有问题，任务执行完毕时会释放相应的资源。</p>
<p>然而，在进行测试时，多次执行任务后出现了<code>Metaspace OOM</code>异常。通过测试用例也复现了该异常。</p>
<p>为了避免<code>Metaspace</code>太小导致来不及回收，测试用例给了<code>2g</code>的<code>MetaspaceSize</code>：<code>-XX:MetaspaceSize=2g -XX:MaxMetaspaceSize=2g</code>。</p>
<p>通过VisualVM 监控 JUnitStarter 发现<code>Metaspace</code>不断增长，并未被清理。而且加载的<code>Classes</code>数量高达 <strong>268,288</strong>！</p>
<p><img src="/2023/07/31/flink-oom-record/img1.png" alt="img1.png"></p>
<p>从错误日志来看，<code>AkkaRpcService</code>通过反射加载了一些类，但<code>MetaspaceSize</code>显然不够。至于为什么不够，目前还无法确定。但可以猜测这些通过反射加载的类没有被释放。</p>
<p><img src="/2023/07/31/flink-oom-record/img1-2.png" alt="img1-2.png"></p>
<p>通过刚才的报错已经拿到了<code>HeapDump</code>文件，可以使用 Eclipse 的 MAT 工具来加载<code>Dump</code>文件进行分析。</p>
<p><img src="/2023/07/31/flink-oom-record/img1-3.png" alt="img1-3.png"></p>
<p>由于已经有了明确的方向，直接选择查看重复加载的类。</p>
<p><img src="/2023/07/31/flink-oom-record/img1-4.png" alt="img1-4.png"></p>
<p>测试用例大约执行了 152 次，然后出现了问题。可以看到一大片 <code>count=151</code>的类，证明刚才的猜测是正确的。</p>
<p>现在需要排查这些类为什么没有被释放。首先检查是否存在强引用这些类的<code>GC Root</code>。</p>
<p><img src="/2023/07/31/flink-oom-record/img2.png" alt="img2.png"></p>
<p>可以看到<code>ApplicationShutdownHooks</code>中的<code>IdentityHashMap</code>存储了<code>MemoryExecutionGraphInfoStore</code>，因此<code>JVM</code>无法将<code>MemoryExecutionGraphInfoStore</code>相关的资源做回收。</p>
<p>这里就不详细介绍 <code>ApplicationShutdownHooks</code>。</p>
<p>接着查看<code>MemoryExecutionGraphInfoStore</code>的源码。</p>
<p><img src="/2023/07/31/flink-oom-record/img3.png" alt="img3.png"></p>
<p>当使用<code>Flink</code>的本地模式时，任务会在本地的虚拟<code>MiniCluster</code>中运行。可以看到<code>MiniCluster</code>中创建了<code>MemoryExecutionGraphInfoStore</code>。</p>
<p><img src="/2023/07/31/flink-oom-record/img4.png" alt="img4.png"></p>
<p>在<code>MiniCluster</code>及其相关代码中没有找到调用<code>MemoryExecutionGraphInfoStore</code>的<code>close()</code>方法，但在<code>Flink</code>的集群模式中，<code>JobClusterEntrypoint</code>的父类<code>ClusterEntrypoint</code>中有明确的调用。</p>
<p><img src="/2023/07/31/flink-oom-record/img5.png" alt="img5.png"></p>
<p>虽然还不清楚为什么<code>MiniCluster</code>不去调用<code>MemoryExecutionGraphInfoStore</code>的<code>close()</code>方法，但要解决<code>Metaspace OOM</code>，肯定要从这里入手。</p>
<p>考虑到<code>ExecutionGraphInfoStore</code>经过了多层封装，无法直接调用<code>close()</code>方法。在深思熟虑后（我直接冲），决定使用危险的反射方法来获取私有变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleDataWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="type">StreamExecutionProps</span> <span class="variable">props</span> <span class="operator">=</span> JsonUtils.objectMapper.readValue(readJson(<span class="string">&quot;props.json&quot;</span>), StreamExecutionProps.class);</span><br><span class="line">     props.fieldTypesAndRowTypeInit();</span><br><span class="line">     <span class="type">DbInfo</span> <span class="variable">nebula</span> <span class="operator">=</span> JsonUtils.objectMapper.readValue(readJson(<span class="string">&quot;nebula.json&quot;</span>), DbInfo.class);</span><br><span class="line">     <span class="type">DbInfo</span> <span class="variable">es</span> <span class="operator">=</span> JsonUtils.objectMapper.readValue(readJson(<span class="string">&quot;es.json&quot;</span>), DbInfo.class);</span><br><span class="line">     <span class="type">MiniClusterJobClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> (<span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironmentBuilder.env(props, nebula, es)) &#123;</span><br><span class="line">         client = (MiniClusterJobClient) env.executeAsync();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(e.getMessage(), e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (Objects.nonNull(client)) &#123;</span><br><span class="line">             <span class="comment">// 无论成功或失败都关闭 executionGraphInfoStore</span></span><br><span class="line">             <span class="type">MiniCluster</span> <span class="variable">miniCluster</span> <span class="operator">=</span> PriUtil.get(client, <span class="string">&quot;miniCluster&quot;</span>, MiniCluster.class);</span><br><span class="line">             Collection&lt;DispatcherResourceManagerComponent&gt; components = PriUtil.get(miniCluster,</span><br><span class="line">                     <span class="string">&quot;dispatcherResourceManagerComponents&quot;</span>, Collection.class);</span><br><span class="line">             components.stream().forEach(c -&gt; closeStore(c));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeStore</span><span class="params">(DispatcherResourceManagerComponent component)</span> &#123;</span><br><span class="line">    DispatcherRunnerLeaderElectionLifecycleManager&lt;DefaultDispatcherRunner&gt; lifecycleManager = PriUtil.get(component,</span><br><span class="line">            <span class="string">&quot;dispatcherRunner&quot;</span>, DispatcherRunnerLeaderElectionLifecycleManager.class);</span><br><span class="line">    <span class="type">DefaultDispatcherRunner</span> <span class="variable">dispatcherRunner</span> <span class="operator">=</span> PriUtil.get(lifecycleManager,</span><br><span class="line">            <span class="string">&quot;dispatcherRunner&quot;</span>, DefaultDispatcherRunner.class);</span><br><span class="line">    <span class="type">SessionDispatcherLeaderProcessFactory</span> <span class="variable">dispatcherLeaderProcessFactory</span> <span class="operator">=</span> PriUtil.get(dispatcherRunner,</span><br><span class="line">            <span class="string">&quot;dispatcherLeaderProcessFactory&quot;</span>, SessionDispatcherLeaderProcessFactory.class);</span><br><span class="line">    <span class="type">DefaultDispatcherGatewayServiceFactory</span> <span class="variable">defaultDispatcherGatewayServiceFactory</span> <span class="operator">=</span> PriUtil.get(dispatcherLeaderProcessFactory,</span><br><span class="line">            <span class="string">&quot;dispatcherGatewayServiceFactory&quot;</span>, DefaultDispatcherGatewayServiceFactory.class);</span><br><span class="line">    <span class="type">PartialDispatcherServices</span> <span class="variable">partialDispatcherServices</span> <span class="operator">=</span> PriUtil.get(defaultDispatcherGatewayServiceFactory,</span><br><span class="line">            <span class="string">&quot;partialDispatcherServices&quot;</span>, PartialDispatcherServices.class);</span><br><span class="line">    <span class="type">MemoryExecutionGraphInfoStore</span> <span class="variable">store</span> <span class="operator">=</span> (MemoryExecutionGraphInfoStore) partialDispatcherServices.getArchivedExecutionGraphStore();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获取私有变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;F&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;F&gt; F <span class="title function_">get</span><span class="params">(Object instance, String name, Class&lt;F&gt; f)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> instance.getClass().getDeclaredField(name);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>); <span class="comment">// 参数值为true，禁止访问控制检查</span></span><br><span class="line">            <span class="keyword">return</span> (F) field.get(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RestCodeException.error500(<span class="string">&quot;获取$&#123;instance.toString()&#125;私有变量$name 失败 $&#123;e.getMessage()&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，重跑测试用例，<code>Metaspace OOM</code>没有再现。</p>
<p>最后，<strong>不建议在生产环境中使用 Flink 的本地执行方法！</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">xuzhangtian</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
